Java技术总结
==========================
JVM调优
^^^^^^^^^^^^^^

简单的概念
##############
堆与栈
  **栈** 是运行时单位，而 **堆** 是存储单位。每个线程都会有独立的 *线程栈* ，而 *堆* 是所有线程 **共享** 的。

  *栈* 中存的是基本数据类型和堆中对象的引用； *堆* 中存的是对象。

Java中的参数传递时传值呢？还是传引用？
  程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。

Java对象的大小
  一个空Object对象的大小是8byte

  计算下面代码的大小：

  .. code-block:: java

    Class NewObject {
        int count;
        boolean flag;
        Object ob;
    }

  这个类对象的大小是： ``空对象的大小(8byte) + int的大小(4byte) + Boolean大小(1byte) + 空Object的大小(4byte)=17bype`` 。

  但是因为Java在对对象内存分配时都是 **以8的整数倍** 来分，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为 ``24byte`` 。

引用类型
  对象引用类型分为 **强引用** 、 **软引用** 、 **弱引用** 和 **虚引用** 。

  - 强引用:就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收
  - 软引用:软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。
  - 弱引用:弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。

垃圾回收
  基本的策略划分： **引用计数** 、 **标记-清除** 、 **复制** 、 **标记-整理** 、 **分代收集** 、 **增量收集** 。

垃圾回收中的一些问题
########################
参考文章： https://www.cnblogs.com/andy-zhou/p/5327288.html

垃圾回收的起点是？
  垃圾回收的起点是一些根对象（ *java栈* , *静态变量* , *寄存器* ...）

如何处理碎片？
  “复制”方式和“标记-整理”方式，都可以解决碎片的问题。

如何解决同时存在的对象创建和对象回收问题
  1. 在垃圾回收时，暂停整个应用。但这样的缺点是：当堆空间持续增大时，垃圾回收的时间也将会相应的持续增大，对应应用暂停的时间也会相应的增大。如果堆空间是几个G时，垃圾回收将会成为系统运行的一个瓶颈。
  2. 使用 **并发垃圾回收算法** 。缺点是：系统的处理能力也会相应降低，同时，“碎片”问题将会比较难解决。

为什么要分代？
  因为不同的对象的生命周期是不一样的，使用分代可以对不同生命周期的对象采取不同的收集方式，以便提高回收效率。

  一般分为三代：年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）。其中持久代用于存放静态文件，如今Java类、方法等。

什么情况下触发垃圾回收？
  1. Scavenge GC，在创建对象申请空间失败时触发。它只会影响 *年轻代* ，不会触及 *年老代* 。
  2. Full GC，如下情况会触发：年老代被写满；持久代被写满； ``System.gc()`` 被显示调用；上一次GC之后Heap的各域分配策略动态变化。

设置堆大小
  ::

    java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0

  - ``-Xmx3550m`` ：设置JVM最大可用内存为 *3550M* 。
  - ``-Xms3550m`` ：设置JVM初始内存为 *3550m* 。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
  - ``-Xmn2g`` ：设置年轻代大小为 *2G* 。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为 ``64m`` ，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方 **推荐配置** 为整个堆的 ``3/8`` 。
  - ``-Xss128k`` ：设置每个线程的堆栈大小为 *128K* 。JDK5.0以后每个线程堆栈大小为 ``1M`` ，以前每个线程堆栈大小为56K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
  - ``-XX:NewRatio=4`` :设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
  - ``-XX:SurvivorRatio=4`` ：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
  - ``-XX:MaxPermSize=16m`` :设置持久代大小为16m。
  - ``-XX:MaxTenuringThreshold=0`` ：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。这会对年老代比较多的应用，可以 **提高效率** 。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。

如何选择垃圾回收算法
  - 串行垃圾回收处理器：单处理器的机器或数据量小于 ``100M`` 的情况下。 打开方法： ``-XX:+UseSerialGC`` 。

    |jvm_parallel_gc|

  - 并行垃圾回收处理器：适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。使用 ``-XX:+UseParallelOldGC`` 打开。

    |jvm_serial_gc|

    并行年轻代，串行老年代。

    - ``-XX:ParallelGCThreads=`` 设置并行垃圾回收的线程数
    - ``-XX:MaxGCPauseMillis=`` 指定垃圾回收最大暂停时间（毫秒）
    - ``-XX:GCTimeRatio=`` 指定垃圾回收的 **吞吐量** (垃圾回收时间与非垃圾回收时间的比值)，如： ``-XX:GCTimeRatio=19`` 时，表示 ``5%`` （ ``1/(1+19)`` ）的时间用于垃圾回收。默认情况为 ``99`` ，即>1%的时间用于垃圾回收。
    - ``-XX:+UseParallelOldGC`` ：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。
    - ``-XX:+UseAdaptiveSizePolicy`` ：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等， **此值建议使用并行收集器时，一直打开** 。

  - 并发垃圾回收处理器：适用情况：“对响应时间有高要求”（应用看似不暂停），多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。打开方式： ``-XX:+UseConcMarkSweepGC`` 。

    |jvm_concurrence_gc|

    并发收集器主要减少年老代的暂停时间。在每个年老代垃圾回收周期中，在收集初期并发收集器会对整个应用进行简短的暂停（用于初始标记），在收集中还会再暂停一次（用于重新标记）。第二次暂停会比第一次稍长，在暂停过程中多个线程同时进行垃圾回收工作；在两次暂停之间会有一个线程进行 *并发标记* ，其余线程正常工作；两次暂停之后，会有一个线程进行 *并发清扫* 和 *重置* 。

    并行年轻代，串行初始化标记、并发标记、并行重新标记、并发清扫、并发重置。

    - **浮动垃圾** ：上次垃圾回收产生的垃圾。并发收集器一般需要 ``20%`` 的预留空间用于这些浮动垃圾。
    - **并发模式失败** ：并发收集器在应用运行时进行收集，所以需要保证堆在垃圾回收的这段时间有足够的空间供程序使用，否则，垃圾回收还未完成，堆空间先满了。这种情况下将会发生 ``Concurrent Mode Failure`` ，此时整个应用将会暂停，进行垃圾回收。
    - **启动并发收集器** ：因为并发收集在应用运行时进行收集，所以必须保证收集完成之前有足够的内存空间供程序使用，否则会出现 ``Concurrent Mode Failure`` 。通过设置 ``-XX:CMSInitiatingOccupancyFraction=`` 指定还有多少剩余堆时开始执行并发收集。

    参数列表：

    - ``-XX:+UseConcMarkSweepGC`` ：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
    - ``-XX:+UseParNewGC`` : 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置 **自行设置** ，所以 **无需再设置此值** 。
    - ``-XX:CMSFullGCsBeforeCompaction`` ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
    - ``-XX:+UseCMSCompactAtFullCollection`` ：打开对年老代的压缩。可能会影响性能，但是可以消除碎片

JVM的一些辅助的命令行参数
  - ``-XX:+PrintGC`` ：输出形式： ::

      [GC 118250K->113543K(130112K), 0.0094143 secs] [Full GC 121376K->10414K(130112K), 0.0650971 secs]

  - ``-XX:+PrintGCDetails`` ：输出形式：::

      [GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs]

  - ``-XX:+PrintGCTimeStamps -XX:+PrintGC`` ： ``PrintGCTimeStamps`` 可与上面两个混合使用输出形式：::

      11.851: [GC 98328K->93620K(130112K), 0.0082960 secs]

  - ``-XX:+PrintGCApplicationConcurrentTime`` ：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：::

      Application time: 0.5291524 seconds

  - ``-XX:+PrintGCApplicationStoppedTime`` ：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：::

      Total time for which application threads were stopped: 0.0468229 seconds

  - ``-XX:PrintHeapAtGC`` : 打印GC前后的详细堆栈信息。输出形式： ::

      34.702: [GC {Heap before gc invocations=7:
      def new generation total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)
      eden space 49152K, 99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)
      from space 6144K, 55% used [0x221d0000, 0x22527e10, 0x227d0000)
      to space 6144K, 0% used [0x21bd0000, 0x21bd0000, 0x221d0000)
      tenured generation total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)
      the space 69632K, 3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)
      compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)
      the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)
      ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)
      rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)
      34.735: [DefNew: 52568K->3433K(55296K), 0.0072126 secs] 55264K->6615K(124928K)Heap after gc invocations=8:
      def new generation total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)
      eden space 49152K, 0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)
      from space 6144K, 55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)
      to space 6144K, 0% used [0x221d0000, 0x221d0000, 0x227d0000)
      tenured generation total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)
      the space 69632K, 4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)
      compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)
      the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)
      ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)
      rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)
      }
      , 0.0757599 secs]

  - ``-Xloggc:filename`` :与上面几个配合使用，把相关日志信息记录到文件以便分析。

垃圾回收的调优总结
  - 年轻代大小选择

    响应时间优先的应用： *尽可能的设置大* ，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。

    吞吐量优先的应用： *尽可能的设置大* ，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

  - 年老代大小选择

    响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：

    - 并发垃圾收集信息
    - 持久代并发收集次数
    - 传统GC信息
    - 花在年轻代和年老代回收上的时间比例

      减少年轻代和年老代花费的时间，一般会提高应用的效率

  - 吞吐量优先的应用

    一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。

  - 较小堆引起的碎片问题

    因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：

    - ``-XX:+UseCMSCompactAtFullCollection`` ：使用并发收集器时，开启对年老代的压缩。
    - ``-XX:CMSFullGCsBeforeCompaction=0`` ：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩

JVM调优工具
  Jconsole，jProfile，VisualVM

  - Jconsole : jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。
  - JProfiler：商业软件，需要付费。功能强大。
  - VisualVM：JDK自带，功能强大，与JProfiler类似。推荐。

内存泄漏
  一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。

  内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。

  需要区别一下，内存泄漏和系统超负荷两者是有区别的，虽然可能导致的最终结果是一样的。内存泄漏是用完的资源没有回收引起错误，而系统超负荷则是系统确实没有那么多资源可以分配了（其他的资源都在使用）。

  - 年老代堆空间被占满: ``java.lang.OutOfMemoryError: Java heap space``

    这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。

  - 持久代被占满: ``java.lang.OutOfMemoryError: PermGen space``

    这个异常以前是没有的，但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满。

    解决方法：1. ``-XX:MaxPermSize=16m`` ；2. 换用JDK。比如JRocket。

  - 堆栈溢出: ``java.lang.StackOverflowError``

    一般就是递归没返回，或者循环调用造成

  - 线程堆栈满: ``Fatal: Stack size too small``

    java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。

    解决：增加线程栈大小。 ``-Xss2m`` 。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。

  - 系统内存被占满: ``java.lang.OutOfMemoryError: unable to create new native thread``

    分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。

    解决：1. 重新设计系统减少线程数量；2. 线程数量不能减少的情况下，通过 ``-Xss`` 减小单个线程大小。以便能生产更多的线程。

我们的内存中都放了什么？
  - 系统运行时业务相关的数据。比如web应用中的session、即时消息的session等。这些数据一般在一个用户访问周期或者一个使用过程中都需要存在。
  - 缓存。缓存就比较多了，你所要快速访问的都可以放这里面。其实上面的业务数据也可以理解为一种缓存。
  - 线程。

SpringBean 工作原理详解
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
- Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？
- Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。
- Bean的作用于：singleton, prototype, request、session 和 global session。

  - 对有状态的 bean 应该使用 prototype 作用域，而对无状态的 bean 则应该使用 singleton 作用域。

  .. code-block:: java

    @Service
    @Scope("singleton")
    public class ServiceImpl{
      ...
    }

  .. code-block:: xml

    <bean id="account" class="com.foo.DefaultAccount" scope="prototype"/>
     或者
    <bean id="account" class="com.foo.DefaultAccount" singleton="false"/>

    <bean id="loginAction" class=cn.csdn.LoginAction" scope="request"/>

.. |jvm_parallel_gc| image:: /images/jvm/jvm_parallel_gc.png
.. |jvm_serial_gc| image:: /images/jvm/jvm_serial_gc.png
.. |jvm_concurrence_gc| image:: /images/jvm/jvm_concurrence_gc.png
