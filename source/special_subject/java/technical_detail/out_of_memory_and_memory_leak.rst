内存溢出与内存泄漏
==========================
内存溢出 ``out of memory`` 
  是指程序在申请内存时，没有足够的内存空间供其使用，出现 ``out of memory`` 。

内存泄露 ``memory leak`` 
  是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

  ``memory leak`` 会最终会导致 ``out of memory`` ！

内存泄漏可以分为4类：
  - 常发性内存泄漏。发生内存泄漏的代码会 **被多次执行到** ，每次被执行的时候都会导致一块内存泄漏。
  - 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
  - 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
  - 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

内存泄漏的常见场景是：
  - 静态集合类引起内存泄露。静态成员一般不会被垃圾回收，静态集合类里的成员也是如此，如果没有做好这些集合类的 **清除工作** ，就会导致内存泄漏。
  - 当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。 **特别是对象类修改了 hashCode() 、 equals() 方法的时候** 。

    .. code-block:: java

      public static void main(String[] args) {
          Set<Person> set = new HashSet<Person>();
          Person p1 = new Person("唐僧","pwd1",25);
          Person p2 = new Person("孙悟空","pwd2",26);
          Person p3 = new Person("猪八戒","pwd3",27);
          set.add(p1);
          set.add(p2);
          set.add(p3);
          System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素!
          // Persion类修改了hashCode方法，hash的计算掺杂了age因素。
          p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变

          set.remove(p3); //此时remove不掉，造成内存泄漏

          set.add(p3); //重新添加，居然添加成功
          System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素!
          for (Person person : set) {
              System.out.println(person);
          }
      }

  - 监听器。在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。
  - 各种连接。比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。
  - 单例模式。如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。
