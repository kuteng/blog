Java内存模型——JMM
==============================
TPS
  Transactions Per Second，每秒事务处理数。它是衡量一个服务器性能的高低好坏。

硬件的效率与一致性
^^^^^^^^^^^^^^^^^^^^^^^^
由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。

除此之外，为了使得处理器内部的运算单元能竟可能被充分利用，处理器可能会对输入代码进行 **乱起执行** （Out-Of-Order Execution）优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的 *即时编译器* 中也有类似的 **指令重排序** （Instruction Recorder）优化。

|the_diagram_of_hardware_efficiency_and_consistency|

Java内存模型
^^^^^^^^^^^^^^^^^^^^^^^^
|the_diagram_of_java_memory_model_0|

主内存与工作内存
::::::::::::::::::::::::
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了 *实例字段* 、 *静态字段* 和 *构成数组对象的元素* ，但是不包括 *局部变量* 与 *方法参数* ，后者是 **线程私有的，不会被共享** 。

Java内存模型中规定了 **所有的变量都存储在主内存中，每条线程还有自己的工作内存** （可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝， **线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量** 。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和 *多处理器系统的缓存设计* 类似。

|the_diagram_of_java_memory_model_1|

**注意** ：这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。

内存间交互操作
::::::::::::::::::::::
关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。 **Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行** 。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

重排序
:::::::::::::::::::::::::
在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。
  编译器重排序的典型就是通过调整指令顺序，在不改变程序语义的前提下，尽可能的减少寄存器的读取、存储次数，充分复用寄存器的存储值。
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：

|the_diagram_of_java_reorder|

为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：

===================== ========================= =========================================================================================
屏障类型              指令示例                  说明
===================== ========================= =========================================================================================
LoadLoad Barriers     Load1;LoadLoad;Load2      确保Load1数据的装载，之前于在Load2及所有后续装载指令的装载。（ **是发生还是完成？** ）
StoreStore Barriers   Store1;StoreStore;Store2  确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。
LoadStore Barriers    Load1;LoadStore;Store2    确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。
StoreLoad Barriers    Store1;StoreLoad;Load2    确保Store1数据对其他处理器可见（值刷新到内存），之前于Load2及所有后续装载指令的装载
===================== ========================= =========================================================================================

注意：

1. ``StoreLoad Barriers`` 会是该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存指令。
2. ``StoreLoad Barriers`` 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为之前处理器通常要把写缓冲区中的数据全部刷星到内存中（buffer fully flush）。

使用：

- ``unsafe.putOrderedObject`` 类似这样的方法,会插入StoreStore内存屏障。
- ``Unsafe.putVolatileObject`` 则会插入了StoreLoad屏障

同步机制
::::::::::::::::::::::::::
volatile
  一个线程对 volatile 变量的写一定对之后对这个变量的读的线程可见。即：一个线程对 volatile 变量的读一定能看见在它之前最后一个线程对这个变量的写。

  - 当一个线程要使用共享内存中的 volatile 变量时，如图中的变量a，它会直接从主内存中读取，而不使用自己本地内存中的副本。
  - 当一个线程对一个 volatile 变量进行写时，它会将这个共享变量的值刷新到共享内存中。

synchronized
  它作用范围内的代码对于不同线程是互斥的，并且 **线程在释放锁的时候会将共享变量的值刷新到主内存中** 。

volatile和synchronized的比较
  - 当线程对 volatile 变量写时，java 会把值刷新到主内存中；而对于synchronized，指的是当线程释放锁的时候，会将共享变量的值刷新到主内存中。
  - 线程读取volatile变量时，会将本地内存中的共享变量置为无效；对于synchronized来说，当线程 **获取锁时** ，会将当前线程本地内存中的共享变量置为无效。
  - synchronized 扩大了可见影响的范围，扩大到了synchronized作用的代码块。

final
  final关键字可以修饰变量、方法和类，我们这里只讨论final修饰的变量。final变量的特殊之处在于：final 变量一经初始化，就不能改变其值。

  这里的值对于一个对象或者数组来说指的是这个对象或者数组的引用地址。因此，一个线程定义了一个final变量之后，其他任意线程都可以拿到这个变量。但有一点需要注意的是，当这个final变量为对象或者数组时，

三大特性
:::::::::::::::::::::::::::
原子性
  一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。

  注意：64位的long数据的读和写都不是原子操作，即不具有原子性，并发的时候相互干扰了。并发环境下，对 ``Long`` 读写操作都应该 **加锁** 。

可见性
  一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。

  除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。

有序性
  对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。

  Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，

happens-before原则
:::::::::::::::::::::::::
Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。

下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。

- 程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。
- 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。
- volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。
- 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。
- 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。
- 对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。
- 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生 “呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与happens-before原则之间基本没有什么关系，所以衡量并发安全问题一切必须以happens-before 原则为准。

问题
^^^^^^^^^^^^^^^^^^^^
- ``ThreadLocal`` 在Java中的内存模型是什么样的？它是否会在工作内存中有备份？


.. |the_diagram_of_hardware_efficiency_and_consistency| image:: /images/special_subject/java/001_the_diagram_of_hardware_efficiency_and_consistency.jpg
   :width: 80%
.. |the_diagram_of_java_memory_model_0| image:: /images/special_subject/java/001_the_diagram_of_java_memory_model.webp
   :width: 80%
.. |the_diagram_of_java_memory_model_1| image:: /images/special_subject/java/001_the_diagram_of_java_memory_model.jpg
   :width: 80%
.. |the_diagram_of_java_reorder| image:: /images/special_subject/java/001_the_diagram_of_java_reorder.png
   :width: 80%
